// Generated by CoffeeScript 1.10.0
(function() {
  var SafariStyle, WindowAccessor, XcodeStyle, elementsFrom, readWindows1, readWindows2, returnFirstSuccessful, windowAccessor,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  WindowAccessor = (function() {
    function WindowAccessor() {}

    WindowAccessor.prototype.getId = function(window) {
      return window.id();
    };

    WindowAccessor.prototype.getName = function(window) {
      return window.name();
    };

    WindowAccessor.prototype.getElements = function(window) {
      return returnFirstSuccessful([
        function() {
          return [window.target()];
        }, function() {
          return window.tabs();
        }, function() {
          return [window.document()];
        }
      ]);
    };

    WindowAccessor.prototype.getAnchor = function(elements) {
      if (elements.length > 1) {
        return elements.find(function(e) {
          if (e && e.current) {
            return e.current;
          } else {
            debugger;
            return false;
          }
        });
      } else {
        return elements[0];
      }
    };

    WindowAccessor.prototype.getFrontTabIndex = function(window) {
      var e, error;
      try {
        if (window.currentTab) {
          return window.currentTab().index();
        } else if (window.activeTab) {
          return window.activeTab().index();
        }
      } catch (error) {
        e = error;
        return null;
      }
    };

    WindowAccessor.prototype.getUrl = function(element) {
      return returnFirstSuccessful([
        function() {
          return element.url();
        }, function() {
          return element.file().toString();
        }
      ]);
    };

    WindowAccessor.prototype.getElementName = function(element) {
      return element.name();
    };

    return WindowAccessor;

  })();

  XcodeStyle = (function(superClass) {
    extend(XcodeStyle, superClass);

    function XcodeStyle() {
      return XcodeStyle.__super__.constructor.apply(this, arguments);
    }

    XcodeStyle.prototype.getUrl = function(element) {
      return element.fileReference.fullPath()[0];
    };

    XcodeStyle.prototype.getElementName = function(element) {
      return element.fileReference.name()[0];
    };

    return XcodeStyle;

  })(WindowAccessor);

  SafariStyle = (function(superClass) {
    extend(SafariStyle, superClass);

    function SafariStyle() {
      return SafariStyle.__super__.constructor.apply(this, arguments);
    }

    return SafariStyle;

  })(WindowAccessor);

  windowAccessor = function(app) {
    if (app === 'com.apple.dt.Xcode') {
      return new XcodeStyle();
    } else if (['com.google.Chrome.canary', 'com.apple.Safari'].includes(app)) {
      return new SafariStyle();
    } else {
      return new WindowAccessor();
    }
  };

  this.run = function(argv) {
    'use strict';
    var app, filterWindowId;
    app = argv[0];
    filterWindowId = argv[1];
    if (argv.length === 0 || !app || app === '') {
      throw "no args";
    }
    return returnFirstSuccessful([
      function() {
        return readWindows1(app, filterWindowId);
      }, function() {
        return readWindows2(app, filterWindowId);
      }
    ]);
  };

  readWindows1 = function(bundleId, filterWindowId) {
    var accessor, application;
    application = Application(bundleId);
    accessor = windowAccessor(bundleId);
    return JSON.stringify({
      windows: application.windows().map(function(window) {
        return elementsFrom(window, accessor);
      }).filter(function(window) {
        if (filterWindowId) {
          return window.elements[0].window_id === filterWindowId;
        } else {
          return true;
        }
      }).map(function(elements) {
        return {
          elements: elements,
          anchor: accessor.getAnchor(elements)
        };
      })
    });
  };

  elementsFrom = function(window, windowAccessor) {
    var e, elements, error, visibleTabIndex;
    try {
      visibleTabIndex = windowAccessor.getFrontTabIndex(window);
      elements = windowAccessor.getElements(window);
      return elements.map(function(element) {
        var index, isCurrent;
        index = elements.indexOf(element);
        isCurrent = visibleTabIndex ? visibleTabIndex - 1 === index : null;
        return {
          name: windowAccessor.getElementName(element),
          url: windowAccessor.getUrl(element),
          current: isCurrent,
          tab_index: index,
          window_id: windowAccessor.getId(window)
        };
      });
    } catch (error) {
      e = error;
      debugger;
      return [
        {
          err: e.toString(),
          name: windowAccessor.getName(window),
          window_id: windowAccessor.getId(window)
        }
      ];
    }
  };

  readWindows2 = function(bundleId, filterWindowId) {
    var app, appName, error, error1, f, g, lstWins, strURL, windows;
    appName = Application(bundleId).name();
    app = Application('System Events').applicationProcesses[appName];
    lstWins = null;
    try {
      lstWins = app.windows();
    } catch (error) {
      f = error;
      return JSON.stringify({
        err: 'e1: No open documents found in ' + appName
      });
    }
    if (lstWins) {
      try {
        strURL = lstWins[0].attributes['AXDocument'].value();
      } catch (error1) {
        g = error1;
        return JSON.stringify({
          err: 'e2: No open documents found in ' + appName
        });
      }
    }
    windows = lstWins.map(function(w0) {
      return {
        url: w0.attributes['AXDocument'].value(),
        name: w0.attributes['AXTitle'].value()
      };
    });
    return JSON.stringify({
      windows: [
        {
          elements: windows,
          anchor: windows[0]
        }
      ]
    });
  };

  returnFirstSuccessful = function(fns) {
    var e, error, fn, i;
    i = 0;
    while (i < fns.length) {
      fn = fns[i];
      try {
        if (fn.callAsFunction) {
          return fn.callAsFunction();
        } else {
          return fn.apply();
        }
      } catch (error) {
        e = error;
      }
      i++;
    }
    debugger;
    throw 'no calls were successful.';
  };

}).call(this);
